<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>イラストアーカイブ v1.4</title>

<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">

<style>
html, body {
  height: 100%;
  overscroll-behavior: none;
}

body {
  font-family: system-ui, sans-serif;
  margin: 16px;
}

h1 { font-size: 20px; margin-bottom: 10px; }

button {
  cursor: pointer;
}

/* タブ */
.tab-bar {
  display: flex;
  gap: 8px;
  margin-bottom: 12px;
}
.tab-btn {
  padding: 6px 10px;
  border-radius: 4px;
  border: 1px solid #ccc;
  background: #f5f5f5;
}
.tab-btn.active {
  background: #ddd;
  font-weight: 600;
}

/* 入力欄縦並び */
.input-column {
  display: flex;
  flex-direction: column;
  gap: 6px;
  margin-bottom: 12px;
}

.input-column input,
.input-column select,
.input-column button {
  width: 100%;
  box-sizing: border-box;
}

/* 最近使ったタグ + 全タグ */
.tag-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
  margin: 8px 0 4px;
}

.tag-area {
  display: flex;
  flex-wrap: wrap;
  gap: 4px;
  max-height: 80px;
  overflow-y: auto;
}

.tag-area-all {
  display: none;
  flex-wrap: wrap;
  gap: 4px;
  max-height: 120px;
  overflow-y: auto;
  margin-top: 4px;
}

/* 一覧 */
#list {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
  gap: 8px;
}

.card {
  position: relative;
  padding-bottom: 4px;
}

.card img {
  width: 100%;
  display: block;
  cursor: pointer;
}

.author {
  font-size: 10px;
  line-height: 1.1;
  opacity: 0.7;
  margin-top: 1px;
}

/* タグの見た目（統一） */
.tag {
  font-size: 11px;
  padding: 2px 6px;
  border: 1px solid #888;
  border-radius: 6px;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  gap: 4px;
}
.tag.active { outline: 2px solid #333; }

/* 色つきタグ */
.tag.colored {
  color: #000;
  border-color: transparent;
}

/* モーダル全画面 */
#modal {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.9);
  justify-content: center;
  align-items: center;
  z-index: 999;
}

#modalContent {
  position: relative;
  width: 100vw;
  height: 100dvh;
  color: #fff;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

/* モーダル上部バー */
#modalTopBar {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 6px 8px;
  background: rgba(0,0,0,0.8);
  z-index: 2;
}

#modalTopBar-left {
  display: flex;
  align-items: center;
  gap: 4px;
}

#modalTopBar-right {
  margin-left: auto;
  display: flex;
  align-items: center;
  gap: 4px;
}

/* 閉じるボタン */
.modal-close-btn {
  border: none;
  background: #333;
  color: #fff;
  padding: 4px 8px;
  border-radius: 4px;
}

/* 閲覧 / 編集タブ */
.modal-mode-btn {
  border-radius: 4px;
  border: 1px solid #555;
  background: #222;
  color: #fff;
  padding: 2px 8px;
  font-size: 12px;
}
.modal-mode-btn.active {
  background: #fff;
  color: #000;
}

/* モーダルメイン領域 */
#modalMain {
  flex: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

/* 画像エリア */
#modalImageWrapper {
  flex: 1;
  display: flex;
  justify-content: center;
  align-items: center;
  overflow: hidden;
}

#modalImage {
  display: block;
  max-width: 95vw;
  max-height: 95vh;
  cursor: grab;
  user-select: none;
  transform-origin: center center;
}

/* 下部情報エリア */
#modalInfo {
  max-height: 40%;
  overflow-y: auto;
  padding: 8px;
  background: rgba(0,0,0,0.8);
  font-size: 13px;
}

/* 閲覧モードの中身 */
.modal-section {
  margin-bottom: 6px;
}

/* 入力 */
#modalInfo input,
#modalInfo select,
#modalInfo button,
#modalInfo textarea {
  font-size: 13px;
}

/* タグ一覧（モーダル内） */
#modalTagsView,
#modalTagsEdit {
  display: flex;
  flex-wrap: wrap;
  gap: 4px;
}

/* タグ管理セクション */
#tagManageSection {
  margin-top: 8px;
}

.section-block {
  margin-bottom: 16px;
  padding: 8px;
  border-radius: 6px;
  background: #f9f9f9;
}

.section-title {
  font-weight: 600;
  margin-bottom: 8px;
}

#categoryList {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.category-row {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 12px;
}

.category-row input[type="text"] {
  flex: 1;
}

#tagManageList {
  display: flex;
  flex-direction: column;
  gap: 4px;
  max-height: 50vh;
  overflow-y: auto;
}

.tag-manage-row {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 12px;
}
.tag-color-dot {
  width: 12px;
  height: 12px;
  border-radius: 50%;
  border: 1px solid #555;
}

/* 小さめボタン */
.btn-sm {
  font-size: 11px;
  padding: 2px 6px;
}

/* タグ選択モーダル */
#tagSelectModal {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.6);
  justify-content: center;
  align-items: center;
  z-index: 1200;
}

#tagSelectContent {
  background: #fff;
  color: #000;
  width: min(480px, 95vw);
  max-height: 90vh;
  border-radius: 8px;
  padding: 8px;
  display: flex;
  flex-direction: column;
}

#tagSelectHeader {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
}

#tagSelectList {
  flex: 1;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
  padding: 4px;
}

.tag-select-row {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 2px 0;
  font-size: 12px;
}

.tag-select-name {
  flex: 1;
}

.tag-priority-stars {
  font-size: 11px;
  opacity: 0.8;
}

#tagSelectFooter {
  display: flex;
  justify-content: flex-end;
  gap: 8px;
  margin-top: 8px;
}

/* データ管理モーダル（簡易） */
#dataModal {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.6);
  justify-content: center;
  align-items: center;
  z-index: 1100;
}
#dataModalContent {
  background: #fff;
  color: #000;
  width: min(420px, 95vw);
  border-radius: 8px;
  padding: 10px;
  font-size: 13px;
}
#dataModalFooter {
  display: flex;
  justify-content: flex-end;
  gap: 8px;
  margin-top: 8px;
}
</style>
</head>

<body>

<h1>イラストアーカイブ v1.4</h1>

<div class="tab-bar">
  <button id="tabMain" class="tab-btn active">画像一覧</button>
  <button id="tabTags" class="tab-btn">タグ管理</button>
</div>

<!-- 画像一覧タブ -->
<div id="mainSection">

  <div class="input-column">
    <input type="file" id="imageInput" accept="image/*">
    <input type="text" id="urlInput" placeholder="元ツイートURL">
    <input type="text" id="authorInput" placeholder="作者名">
    <input type="text" id="tagInput" placeholder="タグ（カンマ区切り）">

    <button onclick="addItem()">追加</button>
  </div>

  <div style="display:flex; align-items:center; gap:8px; margin-bottom:8px; flex-wrap:wrap;">
    <select id="sortSelect" onchange="render()">
      <option value="dateDesc">作成日時：降順（新しい → 古い）</option>
      <option value="dateAsc">作成日時：昇順（古い → 新しい）</option>
      <option value="fav">お気に入り優先</option>
    </select>

    <button id="dataBtn" class="btn-sm">データ管理</button>
  </div>

  <div class="tag-header">
    <span>最近使ったタグ</span>
    <button id="toggleAllTagsBtn" class="btn-sm">タグ一覧 ▼</button>
  </div>
  <div id="recentTags" class="tag-area"></div>
  <div id="allTags" class="tag-area-all"></div>

  <h3>一覧</h3>
  <div id="list"></div>
</div>

<!-- タグ管理タブ -->
<div id="tagManageSection" style="display:none;">

  <div class="section-block">
    <div class="section-title">分類一覧</div>
    <div style="display:flex; gap:6px; margin-bottom:6px;">
      <input type="text" id="newCategoryName" placeholder="分類名（例：作品）" style="flex:1;">
      <input type="color" id="newCategoryColor" value="#4da3ff">
      <button class="btn-sm" onclick="addCategory()">追加</button>
    </div>
    <div id="categoryList"></div>
  </div>

  <div class="section-block">
    <div class="section-title">タグと分類・優先度</div>
    <div id="tagManageList"></div>
  </div>

</div>

<!-- 画像モーダル -->
<div id="modal">
  <div id="modalContent">

    <div id="modalTopBar">
      <div id="modalTopBar-left">
        <button class="modal-close-btn" onclick="closeModal()">×</button>
        <button id="modeViewBtn" class="modal-mode-btn active">閲覧</button>
        <button id="modeEditBtn" class="modal-mode-btn">編集</button>
      </div>
      <div id="modalTopBar-right">
        <span>⭐</span>
        <button id="favBtn" class="btn-sm"></button>
        <button id="openUrlBtn" class="btn-sm">元ツイート</button>
        <button id="deleteBtn" class="btn-sm">削除</button>
      </div>
    </div>

    <div id="modalMain">
      <div id="modalImageWrapper">
        <img id="modalImage">
      </div>

      <div id="modalInfo">
        <!-- 閲覧モード -->
        <div id="viewMode">
          <div class="modal-section">
            <div>作者: <span id="viewAuthor" style="text-decoration:underline; cursor:pointer;"></span></div>
            <div>URL: <a id="viewUrl" href="#" target="_blank" style="color:#8cf;"></a></div>
          </div>

          <div class="modal-section">
            <label>状態タグ</label>
            <select id="stateSelect">
              <option value="">状態なし</option>
              <option value="完成">完成</option>
              <option value="塗り">塗り</option>
              <option value="線画">線画</option>
              <option value="ラフ">ラフ</option>
              <option value="構想">構想</option>
            </select>
          </div>

          <div class="modal-section">
            <div>タグ</div>
            <div id="modalTagsView"></div>
          </div>
        </div>

        <!-- 編集モード -->
        <div id="editMode" style="display:none;">
          <div class="modal-section">
            <label>元ツイートURL</label><br>
            <input type="text" id="editUrl" style="width:100%;">
          </div>
          <div class="modal-section">
            <label>作者名</label><br>
            <input type="text" id="editAuthor" style="width:100%;">
          </div>
          <div class="modal-section">
            <label>状態タグ</label><br>
            <select id="editStateSelect">
              <option value="">状態なし</option>
              <option value="完成">完成</option>
              <option value="塗り">塗り</option>
              <option value="線画">線画</option>
              <option value="ラフ">ラフ</option>
              <option value="構想">構想</option>
            </select>
          </div>
          <div class="modal-section">
            <label>タグ</label>
            <div id="modalTagsEdit"></div>
            <div style="display:flex; gap:4px; margin-top:4px;">
              <input type="text" id="modalTagInput" placeholder="Enterでタグ追加" style="flex:1;">
              <button class="btn-sm" id="openTagSelectBtn">一覧から選択</button>
            </div>
          </div>
          <div class="modal-section">
            <label>画像差し替え</label><br>
            <input type="file" id="replaceImageInput" accept="image/*">
          </div>
          <div class="modal-section" style="text-align:right;">
            <button class="btn-sm" onclick="cancelEdit()">キャンセル</button>
            <button class="btn-sm" onclick="saveEdit()">保存</button>
          </div>
        </div>
      </div>
    </div>

  </div>
</div>

<!-- タグ/作者選択モーダル -->
<div id="tagSelectModal">
  <div id="tagSelectContent">
    <div id="tagSelectHeader">
      <span style="font-weight:600;">タグ / 作者を選択</span>
    </div>

    <div style="display:flex; gap:4px; margin-bottom:4px; flex-wrap:wrap;">
      <select id="tagSelectMode" style="flex:1;">
        <option value="tag">タグ</option>
        <option value="author">作者</option>
      </select>
      <select id="tagSelectSort" style="flex:1;">
        <option value="priority">優先度：降順</option>
        <option value="name">名前：昇順</option>
        <option value="recent">最近使った順</option>
      </select>
    </div>

    <input type="text" id="tagSelectSearch" placeholder="検索" style="width:100%; margin-bottom:4px;">

    <div id="tagSelectList"></div>

    <div id="tagSelectFooter">
      <button class="btn-sm" id="tagSelectCancelBtn">キャンセル</button>
      <button class="btn-sm" id="tagSelectApplyBtn">追加</button>
    </div>
  </div>
</div>

<!-- データ管理モーダル -->
<div id="dataModal">
  <div id="dataModalContent">
    <div style="font-weight:600; margin-bottom:6px;">データ管理</div>
    <div style="font-size:12px; margin-bottom:8px;">
      この端末のデータをJSONとしてエクスポート / インポートできます。<br>
      PCとiPhone間のデータ移動にも使えます。
    </div>
    <div style="display:flex; flex-direction:column; gap:6px;">
      <button id="exportBtn" class="btn-sm">エクスポート（JSONダウンロード）</button>
      <button id="importBtn" class="btn-sm">インポート（JSON読み込み）</button>
      <input type="file" id="importInput" accept="application/json" style="display:none;">
    </div>
    <div id="dataModalFooter">
      <button class="btn-sm" id="dataModalCloseBtn">閉じる</button>
    </div>
  </div>
</div>

<script>
/* ===== IndexedDB & 状態 ===== */
let db;
let items = [];
let activeTag = null;
let activeAuthor = null;
let currentItem = null;
let modalMode = "view";

let categories = [];          // {id, name, color}
let tagCategoryList = [];     // {tag, categoryId, priority}
let tagCategoryMap = {};      // tag -> {categoryId, priority}

const DB_VERSION = 3;

const req = indexedDB.open("artDB", DB_VERSION);

req.onupgradeneeded = e => {
  db = e.target.result;

  if (!db.objectStoreNames.contains("arts")) {
    db.createObjectStore("arts", { keyPath: "id" });
  }
  if (!db.objectStoreNames.contains("categories")) {
    db.createObjectStore("categories", { keyPath: "id" });
  }
  if (!db.objectStoreNames.contains("tagCategories")) {
    const store = db.createObjectStore("tagCategories", { keyPath: "tag" });
    // v3でpriority追加（既存データはundefined扱い）
  }
};

req.onsuccess = e => {
  db = e.target.result;
  loadAll();
  loadCategories();
  loadTagCategories();
  restoreFromBackupIfNeeded();
};

req.onerror = e => {
  console.error("IndexedDB error", e.target.error);
};

/* ===== タブ切り替え ===== */
const tabMain = document.getElementById("tabMain");
const tabTags = document.getElementById("tabTags");
const mainSection = document.getElementById("mainSection");
const tagManageSection = document.getElementById("tagManageSection");

tabMain.onclick = () => {
  tabMain.classList.add("active");
  tabTags.classList.remove("active");
  mainSection.style.display = "";
  tagManageSection.style.display = "none";
};

tabTags.onclick = () => {
  tabTags.classList.add("active");
  tabMain.classList.remove("active");
  mainSection.style.display = "none";
  tagManageSection.style.display = "";
  renderTagManager();
};

/* ===== DB操作 ===== */
function saveItem(item, skipBackup=false) {
  const tx = db.transaction("arts", "readwrite");
  tx.objectStore("arts").put(item);
  tx.oncomplete = () => {
    if (!skipBackup) autoBackup();
  };
}

function deleteItem(id, skipBackup=false) {
  const tx = db.transaction("arts", "readwrite");
  tx.objectStore("arts").delete(id);
  tx.oncomplete = () => {
    if (!skipBackup) autoBackup();
  };
}

function loadAll() {
  const tx = db.transaction("arts", "readonly");
  tx.objectStore("arts").getAll().onsuccess = e => {
    items = e.target.result || [];
    render();
  };
}

function loadCategories() {
  const tx = db.transaction("categories", "readonly");
  tx.objectStore("categories").getAll().onsuccess = e => {
    categories = e.target.result || [];
    renderTags();
    renderModalTagsView();
    renderModalTagsEdit();
    renderTagManager();
  };
}

function loadTagCategories() {
  const tx = db.transaction("tagCategories", "readonly");
  tx.objectStore("tagCategories").getAll().onsuccess = e => {
    tagCategoryList = e.target.result || [];
    rebuildTagCategoryMap();
    renderTags();
    renderModalTagsView();
    renderModalTagsEdit();
    renderTagManager();
  };
}

function rebuildTagCategoryMap() {
  tagCategoryMap = {};
  tagCategoryList.forEach(tc => {
    tagCategoryMap[tc.tag] = {
      categoryId: tc.categoryId || null,
      priority: typeof tc.priority === "number" ? tc.priority : 0
    };
  });
}

function addCategory() {
  const nameInput = document.getElementById("newCategoryName");
  const colorInput = document.getElementById("newCategoryColor");
  const name = nameInput.value.trim();
  const color = colorInput.value;

  if (!name) {
    alert("分類名を入力してください");
    return;
  }

  const id = Date.now();
  const cat = { id, name, color };
  const tx = db.transaction("categories", "readwrite");
  tx.objectStore("categories").put(cat).onsuccess = () => {
    categories.push(cat);
    nameInput.value = "";
    autoBackup();
    renderTagManager();
    renderTags();
    renderModalTagsView();
    renderModalTagsEdit();
  };
}

function updateCategory(cat) {
  const tx = db.transaction("categories", "readwrite");
  tx.objectStore("categories").put(cat).onsuccess = () => {
    autoBackup();
    renderTagManager();
    renderTags();
    renderModalTagsView();
    renderModalTagsEdit();
  };
}

function deleteCategory(id) {
  if (!confirm("この分類を削除しますか？\n（紐づくタグは分類なしになります）")) return;

  const tx = db.transaction("categories", "readwrite");
  tx.objectStore("categories").delete(id).onsuccess = () => {
    categories = categories.filter(c => c.id !== id);

    const tx2 = db.transaction("tagCategories", "readwrite");
    const store = tx2.objectStore("tagCategories");
    tagCategoryList.forEach(tc => {
      if (tc.categoryId === id) {
        store.put({ tag: tc.tag, categoryId: null, priority: tc.priority || 0 });
      }
    });
    tx2.oncomplete = () => {
      tagCategoryList = tagCategoryList.map(tc =>
        tc.categoryId === id ? { ...tc, categoryId: null } : tc
      );
      rebuildTagCategoryMap();
      autoBackup();
      renderTagManager();
      renderTags();
      renderModalTagsView();
      renderModalTagsEdit();
    };
  };
}

function setTagCategory(tag, categoryId) {
  const existing = tagCategoryList.find(tc => tc.tag === tag);
  const priority = existing ? (existing.priority || 0) : 0;

  const tx = db.transaction("tagCategories", "readwrite");
  const store = tx.objectStore("tagCategories");

  if (!categoryId && priority === 0) {
    store.delete(tag).onsuccess = () => {
      tagCategoryList = tagCategoryList.filter(tc => tc.tag !== tag);
      rebuildTagCategoryMap();
      autoBackup();
      renderTagManager();
      renderTags();
      renderModalTagsView();
      renderModalTagsEdit();
    };
    return;
  }

  const obj = { tag, categoryId: categoryId || null, priority };
  store.put(obj).onsuccess = () => {
    const idx = tagCategoryList.findIndex(tc => tc.tag === tag);
    if (idx >= 0) tagCategoryList[idx] = obj; else tagCategoryList.push(obj);
    rebuildTagCategoryMap();
    autoBackup();
    renderTagManager();
    renderTags();
    renderModalTagsView();
    renderModalTagsEdit();
  };
}

function setTagPriority(tag, priority) {
  const existing = tagCategoryList.find(tc => tc.tag === tag);
  const categoryId = existing ? existing.categoryId : null;

  const tx = db.transaction("tagCategories", "readwrite");
  const store = tx.objectStore("tagCategories");

  if (!categoryId && priority === 0) {
    store.delete(tag).onsuccess = () => {
      tagCategoryList = tagCategoryList.filter(tc => tc.tag !== tag);
      rebuildTagCategoryMap();
      autoBackup();
      renderTagManager();
      renderTags();
      renderModalTagsView();
      renderModalTagsEdit();
    };
    return;
  }

  const obj = { tag, categoryId: categoryId || null, priority };
  store.put(obj).onsuccess = () => {
    const idx = tagCategoryList.findIndex(tc => tc.tag === tag);
    if (idx >= 0) tagCategoryList[idx] = obj; else tagCategoryList.push(obj);
    rebuildTagCategoryMap();
    autoBackup();
    renderTagManager();
    renderTags();
    renderModalTagsView();
    renderModalTagsEdit();
  };
}

function getCategoryById(id) {
  return categories.find(c => c.id === id);
}

function getTagMeta(tag) {
  const meta = tagCategoryMap[tag];
  if (!meta) return { category: null, priority: 0 };
  return {
    category: meta.categoryId ? getCategoryById(meta.categoryId) : null,
    priority: meta.priority || 0
  };
}

/* ===== 追加 ===== */
function addItem() {
  const file = imageInput.files[0];
  if (!file) return alert("画像を選択してください");

  const reader = new FileReader();
  reader.onload = () => {
    const now = new Date().toISOString();
    const tags = tagInput.value.split(",").map(t=>t.trim()).filter(Boolean);

    const item = {
      id: Date.now(),
      image: reader.result,
      url: urlInput.value,
      author: authorInput.value,
      state: "",
      tags,
      favorite: false,
      createdAt: now
    };

    items.unshift(item);
    saveItem(item);

    imageInput.value = urlInput.value = authorInput.value = tagInput.value = "";
    render();
  };
  reader.readAsDataURL(file);
}

/* ===== 表示 ===== */
function render() {
  renderTags();
  renderList();
}

/* タグ一覧（最近使った＋全タグ） */
function renderTags() {
  const recentContainer = document.getElementById("recentTags");
  const allContainer = document.getElementById("allTags");
  if (!recentContainer || !allContainer) return;
  recentContainer.innerHTML = "";
  allContainer.innerHTML = "";

  const tagLastUsed = {};
  items.forEach(item => {
    const when = item.createdAt || new Date(item.id).toISOString();
    (item.tags || []).forEach(t => {
      if (!tagLastUsed[t] || tagLastUsed[t] < when) {
        tagLastUsed[t] = when;
      }
    });
  });

  const allTagsArr = Object.keys(tagLastUsed);

  allTagsArr.sort((a,b) => {
    const ma = getTagMeta(a);
    const mb = getTagMeta(b);
    if (mb.priority !== ma.priority) return mb.priority - ma.priority;
    if (tagLastUsed[b] !== tagLastUsed[a]) return tagLastUsed[b].localeCompare(tagLastUsed[a]);
    return a.localeCompare(b);
  });

  allTagsArr.forEach(t => {
    const span = document.createElement("span");
    span.className = "tag" + (t === activeTag ? " active" : "");
    const meta = getTagMeta(t);
    if (meta.category) {
      span.classList.add("colored");
      span.style.backgroundColor = meta.category.color;
    }
    span.textContent = t;
    span.onclick = () => {
      activeTag = (activeTag === t) ? null : t;
      activeAuthor = null;
      render();
    };
    recentContainer.appendChild(span);
  });

  const allTagsSorted = [...allTagsArr].sort((a,b) => {
    const ma = getTagMeta(a);
    const mb = getTagMeta(b);
    if (mb.priority !== ma.priority) return mb.priority - ma.priority;
    return a.localeCompare(b);
  });

  allTagsSorted.forEach(t => {
    const span = document.createElement("span");
    span.className = "tag" + (t === activeTag ? " active" : "");
    const meta = getTagMeta(t);
    if (meta.category) {
      span.classList.add("colored");
      span.style.backgroundColor = meta.category.color;
    }
    span.textContent = t;
    span.onclick = () => {
      activeTag = (activeTag === t) ? null : t;
      activeAuthor = null;
      render();
    };
    allContainer.appendChild(span);
  });
}

/* 全タグ展開ボタン */
const toggleAllTagsBtn = document.getElementById("toggleAllTagsBtn");
const allTagsDiv = document.getElementById("allTags");
let allTagsVisible = false;
toggleAllTagsBtn.onclick = () => {
  allTagsVisible = !allTagsVisible;
  allTagsDiv.style.display = allTagsVisible ? "flex" : "none";
  toggleAllTagsBtn.textContent = allTagsVisible ? "タグ一覧 ▲" : "タグ一覧 ▼";
};

/* 一覧（カード） */
function renderList() {
  const container = document.getElementById("list");
  container.innerHTML = "";

  let filtered = items.filter(i =>
    (!activeTag || (i.tags || []).includes(activeTag)) &&
    (!activeAuthor || i.author === activeAuthor)
  );

  if (sortSelect.value === "dateAsc") {
    filtered = [...filtered].sort((a,b) => {
      const ta = a.createdAt || new Date(a.id).toISOString();
      const tb = b.createdAt || new Date(b.id).toISOString();
      return ta.localeCompare(tb);
    });
  } else if (sortSelect.value === "dateDesc") {
    filtered = [...filtered].sort((a,b) => {
      const ta = a.createdAt || new Date(a.id).toISOString();
      const tb = b.createdAt || new Date(b.id).toISOString();
      return tb.localeCompare(ta);
    });
  } else if (sortSelect.value === "fav") {
    filtered = [...filtered].sort((a,b) => {
      if (b.favorite !== a.favorite) return b.favorite - a.favorite;
      const ta = a.createdAt || new Date(a.id).toISOString();
      const tb = b.createdAt || new Date(b.id).toISOString();
      return tb.localeCompare(ta);
    });
  }

  filtered.forEach(i => {
    const div = document.createElement("div");
    div.className = "card";

    const img = document.createElement("img");
    img.src = i.image;
    img.onclick = () => openModal(i);

    const author = document.createElement("div");
    author.className = "author";
    author.textContent = i.author || "";

    div.append(img, author);
    container.appendChild(div);
  });
}

/* ===== タグ管理画面 ===== */
function renderTagManager() {
  const catList = document.getElementById("categoryList");
  const tagList = document.getElementById("tagManageList");
  if (!catList || !tagList) return;

  catList.innerHTML = "";
  categories.forEach(cat => {
    const row = document.createElement("div");
    row.className = "category-row";

    const color = document.createElement("input");
    color.type = "color";
    color.value = cat.color;
    color.onchange = () => {
      cat.color = color.value;
      updateCategory(cat);
    };

    const name = document.createElement("input");
    name.type = "text";
    name.value = cat.name;
    name.onchange = () => {
      cat.name = name.value.trim();
      updateCategory(cat);
    };

    const del = document.createElement("button");
    del.textContent = "削除";
    del.className = "btn-sm";
    del.onclick = () => deleteCategory(cat.id);

    row.append(color, name, del);
    catList.appendChild(row);
  });

  tagList.innerHTML = "";
  const allTags = [...new Set(items.flatMap(i => i.tags || []))].sort();

  allTags.forEach(tag => {
    const row = document.createElement("div");
    row.className = "tag-manage-row";

    const dot = document.createElement("div");
    dot.className = "tag-color-dot";

    const meta = getTagMeta(tag);
    if (meta.category) {
      dot.style.backgroundColor = meta.category.color;
    } else {
      dot.style.backgroundColor = "#fff";
    }

    const label = document.createElement("span");
    label.textContent = tag;

    const selectCat = document.createElement("select");
    const optNone = document.createElement("option");
    optNone.value = "";
    optNone.textContent = "分類なし";
    selectCat.appendChild(optNone);

    categories.forEach(c => {
      const op = document.createElement("option");
      op.value = String(c.id);
      op.textContent = c.name;
      selectCat.appendChild(op);
    });

    if (meta.category) selectCat.value = String(meta.category.id);
    else selectCat.value = "";

    selectCat.onchange = () => {
      const val = selectCat.value;
      const cid = val ? Number(val) : null;
      setTagCategory(tag, cid);
    };

    const selectPri = document.createElement("select");
    const priOptions = [
      { v: "0", label: "優先度なし" },
      { v: "1", label: "⭐︎" },
      { v: "2", label: "⭐︎⭐︎" },
      { v: "3", label: "⭐︎⭐︎⭐︎" }
    ];
    priOptions.forEach(p => {
      const op = document.createElement("option");
      op.value = p.v;
      op.textContent = p.label;
      selectPri.appendChild(op);
    });
    selectPri.value = String(meta.priority || 0);
    selectPri.onchange = () => {
      const p = Number(selectPri.value);
      setTagPriority(tag, p);
    };

    row.append(dot, label, selectCat, selectPri);
    tagList.appendChild(row);
  });
}

/* ===== モーダル ===== */
const modal = document.getElementById("modal");
const modalImage = document.getElementById("modalImage");
const favBtn = document.getElementById("favBtn");
const stateSelect = document.getElementById("stateSelect");
const editStateSelect = document.getElementById("editStateSelect");
const openUrlBtn = document.getElementById("openUrlBtn");
const deleteBtn = document.getElementById("deleteBtn");
const viewAuthorSpan = document.getElementById("viewAuthor");
const viewUrlLink = document.getElementById("viewUrl");
const editUrlInput = document.getElementById("editUrl");
const editAuthorInput = document.getElementById("editAuthor");
const modalTagsViewDiv = document.getElementById("modalTagsView");
const modalTagsEditDiv = document.getElementById("modalTagsEdit");
const modalTagInput = document.getElementById("modalTagInput");
const replaceImageInput = document.getElementById("replaceImageInput");
const modeViewBtn = document.getElementById("modeViewBtn");
const modeEditBtn = document.getElementById("modeEditBtn");
const viewModeDiv = document.getElementById("viewMode");
const editModeDiv = document.getElementById("editMode");

function setModalMode(mode) {
  modalMode = mode;
  if (mode === "view") {
    modeViewBtn.classList.add("active");
    modeEditBtn.classList.remove("active");
    viewModeDiv.style.display = "";
    editModeDiv.style.display = "none";
  } else {
    modeEditBtn.classList.add("active");
    modeViewBtn.classList.remove("active");
    viewModeDiv.style.display = "none";
    editModeDiv.style.display = "";
  }
}

modeViewBtn.onclick = () => setModalMode("view");
modeEditBtn.onclick = () => setModalMode("edit");

function openModal(item) {
  currentItem = JSON.parse(JSON.stringify(item));
  modal.style.display = "flex";
  setupModalImage(item.image);

  favBtn.textContent = item.favorite ? "解除" : "お気に入り";

  viewAuthorSpan.textContent = item.author || "";
  if (item.url) {
    viewUrlLink.textContent = item.url;
    viewUrlLink.href = item.url;
  } else {
    viewUrlLink.textContent = "";
    viewUrlLink.href = "#";
  }

  editUrlInput.value = item.url || "";
  editAuthorInput.value = item.author || "";

  stateSelect.value = item.state || "";
  editStateSelect.value = item.state || "";

  renderModalTagsView();
  renderModalTagsEdit();

  replaceImageInput.value = "";

  setModalMode("view");
}

/* 画像ズーム・ドラッグ */
let scale = 1, posX = 0, posY = 0;
let startX = 0, startY = 0;
let isDragging = false;

function setupModalImage(src) {
  modalImage.src = src;
  scale = 1;
  posX = 0;
  posY = 0;
  modalImage.style.transform = "translate(0px,0px) scale(1)";
}

modalImage.onmousedown = e => {
  e.preventDefault();
  isDragging = true;
  startX = e.clientX - posX;
  startY = e.clientY - posY;
  modalImage.style.cursor = "grabbing";
};

document.onmousemove = e => {
  if (!isDragging) return;
  posX = e.clientX - startX;
  posY = e.clientY - startY;
  modalImage.style.transform = `translate(${posX}px,${posY}px) scale(${scale})`;
};

document.onmouseup = () => {
  isDragging = false;
  modalImage.style.cursor = "grab";
};

modalImage.ondblclick = () => {
  scale = (scale === 1 ? 2 : 1);
  modalImage.style.transform = `translate(${posX}px,${posY}px) scale(${scale})`;
};

window.addEventListener("wheel", e => {
  if (modal.style.display !== "flex") return;
  if (e.ctrlKey) e.preventDefault();
  const delta = e.deltaY;
  const zoomFactor = 1.05;
  if (delta < 0) scale *= zoomFactor;
  else scale /= zoomFactor;
  scale = Math.max(0.2, Math.min(scale, 8));
  modalImage.style.transform = `translate(${posX}px,${posY}px) scale(${scale})`;
}, { passive: false });

/* お気に入り */
favBtn.onclick = () => {
  if (!currentItem) return;
  const original = items.find(i => i.id === currentItem.id);
  if (!original) return;
  original.favorite = !original.favorite;
  saveItem(original);
  favBtn.textContent = original.favorite ? "解除" : "お気に入り";
  render();
};

/* 状態タグ（閲覧） */
stateSelect.onchange = () => {
  if (!currentItem) return;
  const original = items.find(i => i.id === currentItem.id);
  if (!original) return;
  original.state = stateSelect.value;
  editStateSelect.value = original.state;
  saveItem(original);
  render();
  showStateNotification(`状態: ${original.state || "なし"}`);
};

/* 状態タグ（編集） */
editStateSelect.onchange = () => {
  if (!currentItem) return;
  currentItem.state = editStateSelect.value;
};

/* URLボタン */
openUrlBtn.onclick = () => {
  if (currentItem && currentItem.url) {
    window.open(currentItem.url, "_blank");
  }
};

/* 削除 */
deleteBtn.onclick = () => {
  if (!currentItem) return;
  if (confirm("削除する？")) {
    deleteItem(currentItem.id);
    items = items.filter(x => x.id !== currentItem.id);
    closeModal();
    render();
  }
};

/* 作者名クリックで絞り込み */
viewAuthorSpan.onclick = () => {
  if (!currentItem) return;
  if (!currentItem.author) return;
  activeAuthor = currentItem.author;
  activeTag = null;
  closeModal();
  render();
};

/* 閲覧モード用タグ表示 */
function renderModalTagsView() {
  if (!modalTagsViewDiv) return;
  modalTagsViewDiv.innerHTML = "";
  if (!currentItem || !currentItem.tags) return;

  currentItem.tags.forEach(t => {
    const span = document.createElement("span");
    span.className = "tag";
    const meta = getTagMeta(t);
    if (meta.category) {
      span.classList.add("colored");
      span.style.backgroundColor = meta.category.color;
    }
    span.textContent = t;
    modalTagsViewDiv.appendChild(span);
  });
}

/* 編集モード用タグ表示 */
function renderModalTagsEdit() {
  if (!modalTagsEditDiv) return;
  modalTagsEditDiv.innerHTML = "";
  if (!currentItem || !currentItem.tags) return;

  currentItem.tags.forEach(t => {
    const span = document.createElement("span");
    span.className = "tag";
    const meta = getTagMeta(t);
    if (meta.category) {
      span.classList.add("colored");
      span.style.backgroundColor = meta.category.color;
    }
    span.textContent = t + " ×";
    span.onclick = () => {
      if (!currentItem) return;
      currentItem.tags = currentItem.tags.filter(x => x !== t);
      renderModalTagsEdit();
    };
    modalTagsEditDiv.appendChild(span);
  });
}

/* 編集モード：タグ追加（手入力） */
modalTagInput.onkeydown = e => {
  if (e.key === "Enter") {
    if (!currentItem) return;
    const t = modalTagInput.value.trim();
    if (t && !currentItem.tags.includes(t)) {
      currentItem.tags.push(t);
      renderModalTagsEdit();
    }
    modalTagInput.value = "";
  }
};

/* 編集モード：キャンセル */
function cancelEdit() {
  if (!currentItem) return;
  const original = items.find(i => i.id === currentItem.id);
  if (!original) return;
  currentItem = JSON.parse(JSON.stringify(original));
  editUrlInput.value = currentItem.url || "";
  editAuthorInput.value = currentItem.author || "";
  editStateSelect.value = currentItem.state || "";
  renderModalTagsEdit();
  setModalMode("view");
  renderModalTagsView();
}

/* 編集モード：保存 */
function saveEdit() {
  if (!currentItem) return;
  const original = items.find(i => i.id === currentItem.id);
  if (!original) return;

  original.url = editUrlInput.value.trim();
  original.author = editAuthorInput.value.trim();
  original.state = editStateSelect.value;
  original.tags = [...currentItem.tags];

  if (replaceImageInput.files && replaceImageInput.files[0]) {
    const file = replaceImageInput.files[0];
    const reader = new FileReader();
    reader.onload = () => {
      original.image = reader.result;
      finalizeSave(original);
    };
    reader.readAsDataURL(file);
  } else {
    finalizeSave(original);
  }
}

function finalizeSave(original) {
  saveItem(original);
  items = items.map(i => i.id === original.id ? original : i);
  currentItem = JSON.parse(JSON.stringify(original));
  viewAuthorSpan.textContent = original.author || "";
  if (original.url) {
    viewUrlLink.textContent = original.url;
    viewUrlLink.href = original.url;
  } else {
    viewUrlLink.textContent = "";
    viewUrlLink.href = "#";
  }
  stateSelect.value = original.state || "";
  editStateSelect.value = original.state || "";
  setupModalImage(original.image);
  renderModalTagsView();
  renderModalTagsEdit();
  replaceImageInput.value = "";
  setModalMode("view");
  render();
}

/* モーダル閉じる */
function closeModal() {
  modal.style.display = "none";
  currentItem = null;
}
modal.addEventListener("click", e => {
  if (e.target === modal) closeModal();
});
document.addEventListener("keydown", e => {
  if (e.key === "Escape" && modal.style.display === "flex") closeModal();
});

/* ===== 状態通知 ===== */
function showStateNotification(msg) {
  let n = document.createElement("div");
  n.textContent = msg;
  n.style.position = "fixed";
  n.style.bottom = "20%";
  n.style.left = "50%";
  n.style.transform = "translateX(-50%)";
  n.style.background = "rgba(0,0,0,0.7)";
  n.style.color = "white";
  n.style.padding = "6px 12px";
  n.style.borderRadius = "4px";
  n.style.zIndex = 2000;
  document.body.appendChild(n);
  setTimeout(() => n.remove(), 1000);
}

/* ===== タグ/作者選択モーダル ===== */
const tagSelectModal = document.getElementById("tagSelectModal");
const tagSelectMode = document.getElementById("tagSelectMode");
const tagSelectSort = document.getElementById("tagSelectSort");
const tagSelectSearch = document.getElementById("tagSelectSearch");
const tagSelectList = document.getElementById("tagSelectList");
const tagSelectCancelBtn = document.getElementById("tagSelectCancelBtn");
const tagSelectApplyBtn = document.getElementById("tagSelectApplyBtn");
const openTagSelectBtn = document.getElementById("openTagSelectBtn");

let tagSelectSelectedTags = new Set();
let tagSelectSelectedAuthor = null;

openTagSelectBtn.onclick = () => {
  if (!currentItem) return;
  tagSelectMode.value = "tag";
  tagSelectSort.value = "priority";
  tagSelectSearch.value = "";
  tagSelectSelectedTags = new Set(currentItem.tags || []);
  tagSelectSelectedAuthor = currentItem.author || null;
  renderTagSelectList();
  tagSelectModal.style.display = "flex";
};

tagSelectCancelBtn.onclick = () => {
  tagSelectModal.style.display = "none";
};

tagSelectApplyBtn.onclick = () => {
  if (!currentItem) return;
  if (tagSelectMode.value === "tag") {
    const newTags = Array.from(tagSelectSelectedTags);
    currentItem.tags = Array.from(new Set([...currentItem.tags, ...newTags]));
    renderModalTagsEdit();
  } else {
    if (tagSelectSelectedAuthor) {
      editAuthorInput.value = tagSelectSelectedAuthor;
      currentItem.author = tagSelectSelectedAuthor;
    }
  }
  tagSelectModal.style.display = "none";
};

tagSelectMode.onchange = () => {
  tagSelectSearch.value = "";
  renderTagSelectList();
};

tagSelectSort.onchange = () => {
  renderTagSelectList();
};

tagSelectSearch.oninput = () => {
  renderTagSelectList();
};

tagSelectModal.addEventListener("click", e => {
  if (e.target === tagSelectModal) tagSelectModal.style.display = "none";
});

function renderTagSelectList() {
  tagSelectList.innerHTML = "";
  const mode = tagSelectMode.value;
  const keyword = tagSelectSearch.value.trim().toLowerCase();

  if (mode === "tag") {
    const tagLastUsed = {};
    items.forEach(item => {
      const when = item.createdAt || new Date(item.id).toISOString();
      (item.tags || []).forEach(t => {
        if (!tagLastUsed[t] || tagLastUsed[t] < when) {
          tagLastUsed[t] = when;
        }
      });
    });

    let allTags = Object.keys(tagLastUsed);
    if (keyword) {
      allTags = allTags.filter(t => t.toLowerCase().includes(keyword));
    }

    if (tagSelectSort.value === "priority") {
      allTags.sort((a,b) => {
        const ma = getTagMeta(a);
        const mb = getTagMeta(b);
        if (mb.priority !== ma.priority) return mb.priority - ma.priority;
        if (tagLastUsed[b] !== tagLastUsed[a]) return tagLastUsed[b].localeCompare(tagLastUsed[a]);
        return a.localeCompare(b);
      });
    } else if (tagSelectSort.value === "name") {
      allTags.sort((a,b) => {
        const ma = getTagMeta(a);
        const mb = getTagMeta(b);
        if (mb.priority !== ma.priority) return mb.priority - ma.priority;
        return a.localeCompare(b);
      });
    } else if (tagSelectSort.value === "recent") {
      allTags.sort((a,b) => {
        const ta = tagLastUsed[a] || "";
        const tb = tagLastUsed[b] || "";
        if (tb !== ta) return tb.localeCompare(ta);
        const ma = getTagMeta(a);
        const mb = getTagMeta(b);
        if (mb.priority !== ma.priority) return mb.priority - ma.priority;
        return a.localeCompare(b);
      });
    }

    allTags.forEach(tag => {
      const row = document.createElement("div");
      row.className = "tag-select-row";

      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.checked = tagSelectSelectedTags.has(tag);
      checkbox.onchange = () => {
        if (checkbox.checked) tagSelectSelectedTags.add(tag);
        else tagSelectSelectedTags.delete(tag);
      };

      const nameSpan = document.createElement("span");
      nameSpan.className = "tag-select-name";
      nameSpan.textContent = tag;

      const meta = getTagMeta(tag);
      const starSpan = document.createElement("span");
      starSpan.className = "tag-priority-stars";
      if (meta.priority === 1) starSpan.textContent = "⭐︎";
      else if (meta.priority === 2) starSpan.textContent = "⭐︎⭐︎";
      else if (meta.priority === 3) starSpan.textContent = "⭐︎⭐︎⭐︎";
      else starSpan.textContent = "";

      row.append(checkbox, nameSpan, starSpan);
      tagSelectList.appendChild(row);
    });

  } else {
    const authorLastUsed = {};
    const authorCount = {};
    items.forEach(item => {
      const a = (item.author || "").trim();
      if (!a) return;
      const when = item.createdAt || new Date(item.id).toISOString();
      if (!authorLastUsed[a] || authorLastUsed[a] < when) {
        authorLastUsed[a] = when;
      }
      authorCount[a] = (authorCount[a] || 0) + 1;
    });

    let authors = Object.keys(authorLastUsed);
    if (keyword) {
      authors = authors.filter(a => a.toLowerCase().includes(keyword));
    }

    if (tagSelectSort.value === "priority" || tagSelectSort.value === "name") {
      authors.sort((a,b) => a.localeCompare(b));
    } else if (tagSelectSort.value === "recent") {
      authors.sort((a,b) => {
        const ta = authorLastUsed[a] || "";
        const tb = authorLastUsed[b] || "";
        if (tb !== ta) return tb.localeCompare(ta);
        return a.localeCompare(b);
      });
    }

    authors.forEach(author => {
      const row = document.createElement("div");
      row.className = "tag-select-row";

      const radio = document.createElement("input");
      radio.type = "radio";
      radio.name = "authorSelect";
      radio.checked = (tagSelectSelectedAuthor === author);
      radio.onchange = () => {
        tagSelectSelectedAuthor = author;
      };

      const nameSpan = document.createElement("span");
      nameSpan.className = "tag-select-name";
      nameSpan.textContent = author;

      const countSpan = document.createElement("span");
      countSpan.className = "tag-priority-stars";
      countSpan.textContent = `(${authorCount[author] || 0})`;

      row.append(radio, nameSpan, countSpan);
      tagSelectList.appendChild(row);
    });
  }
}

/* ===== データ管理モーダル & エクスポート/インポート ===== */
const dataBtn = document.getElementById("dataBtn");
const dataModal = document.getElementById("dataModal");
const dataModalCloseBtn = document.getElementById("dataModalCloseBtn");
const exportBtn = document.getElementById("exportBtn");
const importBtn = document.getElementById("importBtn");
const importInput = document.getElementById("importInput");

dataBtn.onclick = () => {
  dataModal.style.display = "flex";
};

dataModalCloseBtn.onclick = () => {
  dataModal.style.display = "none";
};

dataModal.addEventListener("click", e => {
  if (e.target === dataModal) dataModal.style.display = "none";
});

exportBtn.onclick = () => {
  if (!db) {
    alert("データベースがまだ開いていません");
    return;
  }
  exportData();
};

importBtn.onclick = () => {
  importInput.value = "";
  importInput.click();
};

importInput.onchange = e => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = () => {
    try {
      const data = JSON.parse(reader.result);
      importData(data);
    } catch (err) {
      console.error(err);
      alert("JSONの読み込みに失敗しました");
    }
  };
  reader.readAsText(file);
};

function exportData() {
  const tx1 = db.transaction("arts", "readonly");
  tx1.objectStore("arts").getAll().onsuccess = e1 => {
    const arts = e1.target.result || [];

    const tx2 = db.transaction("categories", "readonly");
    tx2.objectStore("categories").getAll().onsuccess = e2 => {
      const cats = e2.target.result || [];

      const tx3 = db.transaction("tagCategories", "readonly");
      tx3.objectStore("tagCategories").getAll().onsuccess = e3 => {
        const tagCats = e3.target.result || [];

        const dump = {
          exportedAt: new Date().toISOString(),
          arts,
          categories: cats,
          tagCategories: tagCats
        };

        const json = JSON.stringify(dump, null, 2);
        const blob = new Blob([json], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        const dateStr = new Date().toISOString().replace(/[:.]/g, "-");
        a.href = url;
        a.download = `art-archive-${dateStr}.json`;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      };
    };
  };
}

function importData(data) {
  if (!db) {
    alert("データベースがまだ開いていません");
    return;
  }
  if (!confirm("現在のデータを上書きします。続行しますか？")) return;

  const arts = data.arts || [];
  const cats = data.categories || [];
  const tagCats = data.tagCategories || [];

  const tx = db.transaction(["arts","categories","tagCategories"], "readwrite");
  const artsStore = tx.objectStore("arts");
  const catsStore = tx.objectStore("categories");
  const tagCatsStore = tx.objectStore("tagCategories");

  artsStore.clear();
  catsStore.clear();
  tagCatsStore.clear();

  arts.forEach(a => artsStore.put(a));
  cats.forEach(c => catsStore.put(c));
  tagCats.forEach(t => tagCatsStore.put(t));

  tx.oncomplete = () => {
    alert("インポートが完了しました");
    loadAll();
    loadCategories();
    loadTagCategories();
    autoBackup();
  };
  tx.onerror = e => {
    console.error(e);
    alert("インポート中にエラーが発生しました");
  };
}

/* ===== 自動バックアップ（localStorage） ===== */
const BACKUP_KEY = "artArchiveBackup";

function autoBackup() {
  if (!db) return;
  const tx1 = db.transaction("arts", "readonly");
  tx1.objectStore("arts").getAll().onsuccess = e1 => {
    const arts = e1.target.result || [];
    const tx2 = db.transaction("categories", "readonly");
    tx2.objectStore("categories").getAll().onsuccess = e2 => {
      const cats = e2.target.result || [];
      const tx3 = db.transaction("tagCategories", "readonly");
      tx3.objectStore("tagCategories").getAll().onsuccess = e3 => {
        const tagCats = e3.target.result || [];
        const dump = {
          savedAt: new Date().toISOString(),
          arts,
          categories: cats,
          tagCategories: tagCats
        };
        try {
          localStorage.setItem(BACKUP_KEY, JSON.stringify(dump));
        } catch (err) {
          console.warn("バックアップ保存に失敗", err);
        }
      };
    };
  };
}

function restoreFromBackupIfNeeded() {
  if (!db) return;
  const tx = db.transaction("arts", "readonly");
  tx.objectStore("arts").count().onsuccess = e => {
    const count = e.target.result || 0;
    if (count > 0) return;

    const backupStr = localStorage.getItem(BACKUP_KEY);
    if (!backupStr) return;
    if (!confirm("前回のバックアップからデータを復元しますか？")) return;

    try {
      const data = JSON.parse(backupStr);
      const arts = data.arts || [];
      const cats = data.categories || [];
      const tagCats = data.tagCategories || [];

      const tx2 = db.transaction(["arts","categories","tagCategories"], "readwrite");
      const artsStore = tx2.objectStore("arts");
      const catsStore = tx2.objectStore("categories");
      const tagCatsStore = tx2.objectStore("tagCategories");

      artsStore.clear();
      catsStore.clear();
      tagCatsStore.clear();

      arts.forEach(a => artsStore.put(a));
      cats.forEach(c => catsStore.put(c));
      tagCats.forEach(t => tagCatsStore.put(t));

      tx2.oncomplete = () => {
        loadAll();
        loadCategories();
        loadTagCategories();
      };
    } catch (err) {
      console.error("バックアップ復元失敗", err);
    }
  };
}

/* 終了時バックアップ */
window.addEventListener("beforeunload", () => {
  autoBackup();
});
document.addEventListener("visibilitychange", () => {
  if (document.visibilityState === "hidden") {
    autoBackup();
  }
});
</script>
</body>
</html>
